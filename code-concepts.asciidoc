Here is a pictorial view of the Thrift network stack:
Thrift的网络栈的图示:

["ditaa"]
.The Thrift Network Stack
.Thrift网络栈
-----------------------------------------------------------------------------
+-------------------------------------------+
| cGRE                                      |
| Server                                    |
| (single-threaded, event-driven etc)       |
+-------------------------------------------+
| cBLU                                      |
| Processor                                 |
| (compiler generated)                      |
+-------------------------------------------+
| cGRE                                      |
| Protocol                                  |
| (JSON, compact etc)                       |
+-------------------------------------------+
| cGRE                                      |
| Transport                                 |
| (raw TCP, HTTP etc)                       |
+-------------------------------------------+
-----------------------------------------------------------------------------

Transport
传输
^^^^^^^^^

传输层提供了一个对网络读写简单的抽象.
这使得Thrift可以将底层的传输形式和系统的其他部分(例如序列化反序列化)进行解耦.
The Transport layer provides a simple abstraction for reading/writing from/to
the network. This enables Thrift to decouple the underlying transport from the
rest of the system (serialization/deserialization, for instance).

Here are some of the methods exposed by the +Transport+ interface:
+Transport+接口的主要方法:

* +open+
* +close+
* +read+
* +write+
* +flush+

除了以上的+Transport+ 接口, Thrift也提供了+ServerTransport+接口来接受或创建
原始的传输对象. 顾名思义, +ServerTransport+主要用于服务器端的传入连接创建新的传输对象.
In addition to the +Transport+ interface above, Thrift also uses a
+ServerTransport+ interface used to accept or create primitive transport
objects. As the name suggest, +ServerTransport+ is used mainly on the server
side to create new Transport objects for incoming connections.

* +open+
* +listen+
* +accept+
* +close+

对于大多数Thrift所支持的语言都可以使用以下两种传输方式.
Here are some of the transports available for majority of the Thrift-supported
languages:

* file: read/write to/from a file on disk
* http: as the name suggests

Protocol
协议
^^^^^^^^

协议层抽象定义了如何将内存中的数据结构映射到某个消息约定格式(wire-format).
换句话说, 协议定义了如何将底层的传输数据解码/编码成相应的数据类型.
因此, 协议的实现控制了编码方案, 并且对序列化和反序列化负责.
从这个角度讲, 协议的例子包括JSON, XML, 纯文本, 压缩二进制等.
The Protocol abstraction defines a mechanism to map in-memory data structures to
a wire-format. In other words, a protocol specifies how datatypes use the
underlying Transport to encode/decode themselves.  Thus the protocol
implementation governs the encoding scheme and is responsible for
(de)serialization. Some examples of protocols in this sense include JSON, XML,
plain text, compact binary etc.

+Protocol+ 接口
Here is the +Protocol+ interface:
[source,cpp]
-----------------------------------------------------------------------------
writeMessageBegin(name, type, seq)
writeMessageEnd()
writeStructBegin(name)
writeStructEnd()
writeFieldBegin(name, type, id)
writeFieldEnd()
writeFieldStop()
writeMapBegin(ktype, vtype, size)
writeMapEnd()
writeListBegin(etype, size)
writeListEnd()
writeSetBegin(etype, size)
writeSetEnd()
writeBool(bool)
writeByte(byte)
writeI16(i16)
writeI32(i32)
writeI64(i64)
writeDouble(double)
writeString(string)

name, type, seq = readMessageBegin()
                  readMessageEnd()
name = readStructBegin()
       readStructEnd()
name, type, id = readFieldBegin()
                 readFieldEnd()
k, v, size = readMapBegin()
             readMapEnd()
etype, size = readListBegin()
              readListEnd()
etype, size = readSetBegin()
              readSetEnd()
bool = readBool()
byte = readByte()
i16 = readI16()
i32 = readI32()
i64 = readI64()
double = readDouble()
string = readString()
-----------------------------------------------------------------------------

Thrift协议被设计成面向流的(stream oriented), 因此不需要显示对其进行帧处理.
比如说, 在序列化之前, 无需知道字符串的长度或者列表中元素的数量.
Thrift Protocols are stream oriented by design. There is no need for any
explicit framing. For instance, it is not necessary to know the length of a
string or the number of items in a list before we start serializing them.

对于大多数Thrift所支持的语言都可以使用下列的传输协议.
Here are some of the protocols available for majority of the Thrift-supported
languages:

* binary: Fairly simple binary encoding -- the length and type of a field are
  encoded as bytes followed by the actual value of the field.
* compact: Described in
  https://issues.apache.org/jira/browse/THRIFT-110[THRIFT-110]
* json: 

Processor
处理器
^^^^^^^^^

处理器对从输入流读取数据和向输出流写出数据的功能进行封装.
输出和输出流都是由协议对象代表.
A Processor encapsulates the ability to read data from input streams and write
to output streams. The input and output streams are represented by Protocol
objects. The Processor interface is extremely simple:

处理器接口很简单:

[source,java]
-----------------------------------------------------------------------------
interface TProcessor {
    bool process(TProtocol in, TProtocol out) throws TException
}
-----------------------------------------------------------------------------

编译器会生成特定于服务的处理器的实现.
协议实际上所做的工作就是将数据从消息(wire)中读出(根据输入协议), 在将处理委托给处理程序(handler),
最后将响应写入返回的消息中(使用输出协议).
Service-specific processor implementations are generated by the compiler. The
Processor essentially reads data from the wire (using the input protocol),
delegates processing to the handler (implemented by the user) and writes the
response over the wire (using the output protocol).

Server
服务器
^^^^^^

服务器将所有的特性进行组合
A Server pulls together all of the various features described above:

* 创建一个传输
* Create a transport
* 为传输创建输入输出协议
* Create input/output protocols for the transport
* 基于输入输出协议创建处理器
* Create a processor based on the input/output protocols
* 等待传入连接并将其交给处理器
* Wait for incoming connections and hand them off to the processor

接下来, 我们讨论下为特定语言生成的代码.
除非特别说明, 后面的部分都会使用以下Thrift定义.
Next we discuss the generated code for specific languages. Unless mentioned
otherwise, the sections below will assume the following Thrift specification:

[source,cpp]
.Example IDL
.范例IDL
-----------------------------------------------------------------------------
include::example.thrift[]
-----------------------------------------------------------------------------

.How are nested structs initialized?
.嵌套结构如何初始化?
*****************************************************************************
In an earlier section, we saw how Thrift allows structs to contain other structs
在之前的部分, 我们看到了Thrift是如何使用结构来包含其他的结构(尽管没有嵌套的定义！)
(no nested definitions yet though!) In most object-oriented and/or dynamic
在大多数面向对象或者动态语言中, 结构对应于其中的对象. 因此了解Thrift如何初始化嵌套结构
是有益的.
languages, structs map to objects and so it is instructive to understand how
Thrift initializes nested structs. One reasonable approach would be to treat the
nested structs as pointers or references and initialize them with NULL, until
explicitly set by the user.
一个合理的方法是将嵌套的结构作为指针或者引用, 并且将他们初始化为NULL直到被显示赋值.

Unfortunately, for many languages, Thrift uses a 'pass by value' model. As a
不幸的是, 对很多语言而言, Thrift使用值传递模型.
concrete example, consider the generated C++ code for the +Tweet+ struct in our
example above:
作为一个具体的例子，考虑有上面例子中为+Tweet+结构生成的生成的C++代码:

[source,cpp]
-----------------------------------------------------------------------------
  ...
  int32_t userId;
  std::string userName;
  std::string text;
  Location loc;
  TweetType::type tweetType;
  std::string language;
  ...
-----------------------------------------------------------------------------

As you can see, the nested +Location+ structure is *fully allocated inline*.
Because +Location+ is optional, the code uses the internal '__isset' flags to
determine if the field has actually been "set" by the user.
如你所见, 嵌套的+Location+结构是*完全内联分配*.
因为+Location+是可选的, 代码使用内部标记'__isset'来决定这个域是否被复制.

This can lead to some surprising and unintuitive behavior:
这个可能导致某些意外的非直观行为:

* Since the full size of every sub-structure may be allocated at initialization
  in some languages, memory usage may be higher than you expect, especially for
  complicated structures with many unset fields.
* 因为对于某些语言来说, 需要在初始化时为其中的子结构分配空间, 因此内存使用会比期望的要高.
  对于那些有诸多未设置域的复杂结构体情况尤为突出.
* The parameters and return types for service methods may not be "optional" and
  you can't assign or return +null+ in any dynamic language. Thus to return a
  "no value" result from a method, you must declare an envelope structure with
  an optional field containing the value and then return the envelope with that
  field unset.
* 服务的参数和返回值类型可能不是可选的. 并且你无法在动态语言中将其赋值为或返回null. 因此,
  为了返回一个"无值"的结果, 你必须要申明一个包装结构. 这个包装结构包含了一个可选的域.
  在返回"无值"结果时, 实际上返回的是一个域值为空的包装结构.
* The transport layer can, however, marshal method calls from older versions of
  a service definition with missing parameters. Thus, if the original service
  contained a method +postTweet(1: Tweet tweet)+ and a later version changes it
  to +postTweet(1: Tweet tweet, 2: string group)+, then an older client invoking
  the previous method will result in a newer server receiving the call with the
  new parameter unset. If the new server is in Java, for instance, you may
  in fact receive a +null+ value for the new parameter. And yet you may not
  declare a parameter to be nullable within the IDL.
* 传输层可以处理旧版本的调用(丢失参数). 因此, 如果原始版本包含方法
  +postTweet(1: Tweet tweet)+, 而新版本中将其改为
  +postTweet(1: Tweet tweet, 2: string group)+. 那么基于新版本会接受原始版本的
  客户端发来的请求, 并将新参数定为未设置. 如果新版本服务器是Java实现的, 那么那个缺失的
  新参数的值就会是null. 然而你可能并没有在IDl中将那个参数设置为可为空的.
*****************************************************************************
